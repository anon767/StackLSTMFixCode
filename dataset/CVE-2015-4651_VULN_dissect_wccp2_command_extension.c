static gint  dissect_wccp2_command_extension(tvbuff_t *tvb, int offset,
                                             int length, packet_info *pinfo _U_, proto_tree *info_tree);
static void dissect_wccp2_router_identity_element(tvbuff_t *tvb, int offset, packet_info *pinfo,
                                                  proto_tree *tree);
static gint dissect_wccp2_web_cache_identity_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                     proto_tree *info_tree);
static gint dissect_wccp2_hash_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                       proto_tree *info_tree);
static gint dissect_wccp2_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                       proto_tree *info_tree) ;
static gint dissect_wccp2_alternate_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                                 proto_tree *info_tree);
static gint dissect_wccp2_assignment_weight_and_status_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                               proto_tree *info_tree);
static gint dissect_wccp2_extended_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                           proto_tree *info_tree);
static gint dissect_wccp2_assignment_key_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,
                                                 proto_tree *info_tree);
static void dissect_wccp2_router_assignment_element(tvbuff_t *tvb, int offset, gint length,
                                                    packet_info *pinfo, proto_tree *info_tree) ;
static gint dissect_wccp2_capability_element(tvbuff_t *tvb, int offset, gint length,
                                             packet_info *pinfo _U_, proto_tree *info_tree);
static gint  dissect_wccp2_mask_value_set_list(tvbuff_t *tvb, int offset,
                                               int length, packet_info *pinfo, proto_tree *info_tree);

/* Utility functions */
static gint dissect_wccp2_mask_value_set_element(tvbuff_t *tvb, int offset,
                                                 gint length, int idx, packet_info *pinfo, proto_tree *info_tree);
static gint dissect_wccp2_mask_element(tvbuff_t *tvb, int offset,
                                       gint length, packet_info *pinfo, proto_tree *info_tree);
static gint dissect_wccp2_value_element(tvbuff_t *tvb, int offset,
                                        gint length, int idx, packet_info *pinfo, proto_tree *info_tree);
static gint dissect_wccp2_alternate_mask_value_set_list(tvbuff_t *tvb, int offset,
                                                        gint length, packet_info *pinfo _U_, proto_tree *info_tree);
static gint dissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo, proto_tree *info_tree);
static gint dissect_wccp2_web_cache_value_element(tvbuff_t *tvb, int offset,
                                                  gint length,  packet_info *pinfo, proto_tree *info_tree);
static const gchar *assignment_bucket_name(guint8 bucket);
static void dissect_32_bit_capability_flags(tvbuff_t *tvb, int curr_offset,
                                            guint16 capability_val_len, gint ett, const capability_flag *flags,
                                            proto_tree *element_tree, proto_item *header,
                                            proto_item *length_item, packet_info *pinfo);
static void dissect_transmit_t_capability(tvbuff_t *tvb, proto_item *te, int curr_offset,
                                          guint16 capability_val_len, gint ett, proto_tree *element_tree,
                                          proto_item *length_item, packet_info *pinfo);
static void dissect_timer_scale_capability(tvbuff_t *tvb, int curr_offset,
                                           guint16 capability_val_len, gint ett, proto_tree *element_tree,
                                           proto_item *length_item, packet_info *pinfo);




/*
 * In WCCP 2.01 addresses are encoded to support IPv6 with 32 bit fields
 *
 * handle the decoding
 */

static void
find_wccp_address_table(tvbuff_t *tvb, int offset,
                        packet_info *pinfo, proto_tree *wccp_tree _U_)
{
  guint16 type;
  guint16 item_length;

  /* first clean up: */
  wccp_wccp_address_table.in_use = FALSE;
  wccp_wccp_address_table.family = -1;
  wccp_wccp_address_table.version = -1;
  wccp_wccp_address_table.table_length = 0;
  wccp_wccp_address_table.table_ipv4 = (guint32 *) NULL;
  wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)NULL;

  for (;;) {
    if (4 > tvb_reported_length_remaining(tvb, offset)) {
      /* We've run out of packet data without finding an address table,
         so there's no address table in the packet. */
      return;
    }
    if (4 > tvb_captured_length_remaining(tvb, offset)) {
      /* We've run out of captured date without finding an address table,
         so we've no way of determining whether there's an address table
         or not. */
      return;
    }
    type = tvb_get_ntohs(tvb, offset);
    item_length = tvb_get_ntohs(tvb, offset+2);

    if ((item_length + 4) > tvb_reported_length_remaining(tvb, offset)) {
      /* We've run out of packet data without finding an address table,
         so there's no address table in the packet. */
      return;
    }
    if ((item_length + 4) > tvb_captured_length_remaining(tvb, offset)) {
        /* We've run out of captured date without finding an address table,
           so we've no way of determining whether there's an address table
           or not. */
        return;
      }

    if (type == WCCP2r1_ADDRESS_TABLE)
      {
        dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, pinfo, NULL);
        /* no need to decode the rest */
        return;
      }

    offset = offset + (item_length + 4);
  }
}
