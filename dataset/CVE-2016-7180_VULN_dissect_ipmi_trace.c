dissect_ipmi_trace(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
	guint block_type, chn_num, data_type, tmp;
	tvbuff_t * next_tvb;

	if (tvb_captured_length(tvb) < 11) {
		/* TODO: add expert info */
		call_dissector(data_dissector_handle, tvb, pinfo, tree);
		return;
	}

	/* get first byte */
	tmp = tvb_get_guint8(tvb, 0);

	/* get block type */
	block_type = (tmp >> 4) & 3;

	/* get channel number */
	chn_num = tmp & 0xF;

	/* get trace data type */
	data_type = tvb_get_guint8(tvb, 7);


	col_add_fstr(pinfo->cinfo, COL_DEF_SRC, "Channel %d", chn_num);
	col_set_str(pinfo->cinfo, COL_PROTOCOL,
			val_to_str(data_type, str_protocol_types,
					"Reserved (0x%02x)"));

	col_clear(pinfo->cinfo, COL_INFO);

	if (block_type == HPM2_TRACE_PACKET_DATA) {
		col_set_str(pinfo->cinfo, COL_INFO, "Trace Packet Data");
	} else if (block_type == HPM2_CHN_STATE_NOTIFY) {
		col_set_str(pinfo->cinfo, COL_INFO,
				"Channel State Change Notification");
	} else if (block_type == HPM2_EMBED_ASCII_MSG) {
		char str[257];

		/* get data length */
		guint str_len = tvb_get_guint8(tvb, 10);

		if (str_len) {
			/* copy string */
			tvb_memcpy(tvb, str, 11, str_len);

			/* pad with nul */
			str[str_len] = 0;

			/* print the string right inside the column */
			col_add_str(pinfo->cinfo, COL_INFO, str);
		}
	} else {
		col_set_str(pinfo->cinfo, COL_INFO, "Reserved");
	}


	if ( tree ) {
		proto_item * ti;
		proto_tree * trace_tree;
		proto_tree * stamp_tree;
		nstime_t timestamp;

		/* add protocol label */
		ti = proto_tree_add_item(tree, proto_ipmi_trace, tvb, 0, -1, ENC_NA);

		/* create protocol sub-tree */
		trace_tree = proto_item_add_subtree(ti, ett_ipmi_trace);

		/* add block type/channel bitmask */
		proto_tree_add_bitmask(trace_tree, tvb, 0, hf_trace_block_type,
				ett_trace_block_type, bits_trace_block_type,
				ENC_LITTLE_ENDIAN);

		/* get seconds part */
		timestamp.secs = tvb_get_letohl(tvb, 1);

		/* get milliseconds part */
		timestamp.nsecs = (int) tvb_get_letohs(tvb, 5) * 1000000;

		/* add timestamp */
		ti = proto_tree_add_time(trace_tree, hf_trace_timestamp, tvb, 1,
				6, &timestamp);

		/* create timestamp sub-tree */
		stamp_tree = proto_item_add_subtree(ti, ett_trace_timestamp);

		/* add seconds part */
		proto_tree_add_item(stamp_tree, hf_trace_timestamp_sec,
				tvb, 1, 4, ENC_LITTLE_ENDIAN);

		/* add milliseconds part */
		proto_tree_add_item(stamp_tree, hf_trace_timestamp_msec,
				tvb, 5, 2, ENC_LITTLE_ENDIAN);

		/* add trace data type */
		proto_tree_add_item(trace_tree, hf_trace_data_type,
				tvb, 7, 1, ENC_LITTLE_ENDIAN);

		if (data_type == IPMI_PROTO_IPMB_1_0) {
			/* add ipmb-specific data */
			proto_tree_add_bitmask(trace_tree, tvb, 8,
					hf_trace_protocol_data, ett_trace_protocol_data,
					bits_ipmb_protocol_data, ENC_LITTLE_ENDIAN);
		} else if (data_type == IPMI_PROTO_KCS
				|| data_type == IPMI_PROTO_SMIC
				|| data_type == IPMI_PROTO_BT_10
				|| data_type == IPMI_PROTO_BT_15) {
			/* add host-specific data */
			proto_tree_add_bitmask(trace_tree, tvb, 8,
					hf_trace_protocol_data, ett_trace_protocol_data,
					bits_host_protocol_data, ENC_LITTLE_ENDIAN);
		} else {
			/* add protocol specific data */
			proto_tree_add_item(trace_tree, hf_trace_protocol_data, tvb,
					8, 2, ENC_LITTLE_ENDIAN);
		}

		/* add data length*/
		proto_tree_add_item(trace_tree, hf_trace_data_len, tvb,
				10, 1, ENC_LITTLE_ENDIAN);
	}

	/* get pointer to remaining data buffer */
	next_tvb = tvb_new_subset_remaining(tvb, 11);

	if (block_type == HPM2_TRACE_PACKET_DATA) {
		ipmi_dissect_arg_t arg;

		/* setup IPMI protocol argument */
		arg.context = IPMI_E_NONE;
		arg.channel = chn_num;
		arg.flags	= tvb_get_guint8(tvb, 8);

		if (!dissector_try_uint_new(proto_dissector_table,
				data_type, next_tvb, pinfo, tree, TRUE, &arg)) {
			call_dissector(data_dissector_handle, next_tvb,
					pinfo, tree);
		}
	} else if (block_type == HPM2_CHN_STATE_NOTIFY
			&& data_type == IPMI_PROTO_IPMB_1_0) {
		dissect_ipmb_state_notify(next_tvb, tree);
	} else {
		call_dissector(data_dissector_handle, next_tvb, pinfo, tree);
	}
}
